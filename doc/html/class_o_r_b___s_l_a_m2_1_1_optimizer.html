<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Os1: ORB_SLAM2::Optimizer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Os1
   &#160;<span id="projectnumber">1</span>
   </div>
   <div id="projectbrief">OrbSlam2 documentado y modificado</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,'Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_o_r_b___s_l_a_m2_1_1_optimizer.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_o_r_b___s_l_a_m2_1_1_optimizer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ORB_SLAM2::Optimizer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_o_r_b___s_l_a_m2_1_1_optimizer.html" title="Optimizer concentra todas las operaciones con g2o. ">Optimizer</a> concentra todas las operaciones con <a class="el" href="namespaceg2o.html">g2o</a>.  
 <a href="class_o_r_b___s_l_a_m2_1_1_optimizer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_optimizer_8h_source.html">Optimizer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aac6bf926792ed8a013d64897879a89ec"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_optimizer.html#aac6bf926792ed8a013d64897879a89ec">BundleAdjustment</a> (const std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&gt; &amp;vpKF, const std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&gt; &amp;vpMP, int nIterations=5, bool *pbStopFlag=NULL, const unsigned long nLoopKF=0, const bool bRobust=true)</td></tr>
<tr class="memdesc:aac6bf926792ed8a013d64897879a89ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bundle adjusment sobre los keyframes y puntos el mapa pasados como argumentos.  <a href="#aac6bf926792ed8a013d64897879a89ec">More...</a><br /></td></tr>
<tr class="separator:aac6bf926792ed8a013d64897879a89ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa9b8a4c16296bf2981b0aaf4ee3189c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_optimizer.html#aaa9b8a4c16296bf2981b0aaf4ee3189c">GlobalBundleAdjustemnt</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_map.html">Map</a> *pMap, int nIterations=5, bool *pbStopFlag=NULL, const unsigned long nLoopKF=0, const bool bRobust=true)</td></tr>
<tr class="memdesc:aaa9b8a4c16296bf2981b0aaf4ee3189c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ejecuta BundleAdjstment tomando los datos del mapa.  <a href="#aaa9b8a4c16296bf2981b0aaf4ee3189c">More...</a><br /></td></tr>
<tr class="separator:aaa9b8a4c16296bf2981b0aaf4ee3189c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70e0b4f366b65a0c1ae8b2def19d339"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_optimizer.html#ab70e0b4f366b65a0c1ae8b2def19d339">LocalBundleAdjustment</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pKF, bool *pbStopFlag, <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map.html">Map</a> *pMap)</td></tr>
<tr class="memdesc:ab70e0b4f366b65a0c1ae8b2def19d339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bundle adjusment local a partir de un keyframe.  <a href="#ab70e0b4f366b65a0c1ae8b2def19d339">More...</a><br /></td></tr>
<tr class="separator:ab70e0b4f366b65a0c1ae8b2def19d339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a53ab409feed7f92547eb79a2d7f6e9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_optimizer.html#a5a53ab409feed7f92547eb79a2d7f6e9">OptimizeEssentialGraph</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_map.html">Map</a> *pMap, <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pLoopKF, <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pCurKF, const <a class="el" href="class_o_r_b___s_l_a_m2_1_1_loop_closing.html#ae9ada143a8308ce32990a7c7b5d533ab">LoopClosing::KeyFrameAndPose</a> &amp;NonCorrectedSim3, const <a class="el" href="class_o_r_b___s_l_a_m2_1_1_loop_closing.html#ae9ada143a8308ce32990a7c7b5d533ab">LoopClosing::KeyFrameAndPose</a> &amp;CorrectedSim3, const map&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *, set&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&gt; &gt; &amp;LoopConnections, const bool &amp;bFixScale)</td></tr>
<tr class="memdesc:a5a53ab409feed7f92547eb79a2d7f6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimiza el grafo esencial para cerrar un bucle.  <a href="#a5a53ab409feed7f92547eb79a2d7f6e9">More...</a><br /></td></tr>
<tr class="separator:a5a53ab409feed7f92547eb79a2d7f6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91fbb960965c99e9802a5de45515813c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_optimizer.html#a91fbb960965c99e9802a5de45515813c">OptimizeSim3</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pKF1, <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pKF2, std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&gt; &amp;vpMatches1, <a class="el" href="structg2o_1_1_sim3.html">g2o::Sim3</a> &amp;g2oS12, const float th2, const bool bFixScale)</td></tr>
<tr class="memdesc:a91fbb960965c99e9802a5de45515813c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determina la transformación sim3 entre dos keyframes, que mejor explica un macheo.  <a href="#a91fbb960965c99e9802a5de45515813c">More...</a><br /></td></tr>
<tr class="separator:a91fbb960965c99e9802a5de45515813c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7415d78b8a2323b88e108fa1ea3bf2d3"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_optimizer.html#a7415d78b8a2323b88e108fa1ea3bf2d3">PoseOptimization</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html">Frame</a> *pFrame)</td></tr>
<tr class="memdesc:a7415d78b8a2323b88e108fa1ea3bf2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cómputo de la pose de un cuadro.  <a href="#a7415d78b8a2323b88e108fa1ea3bf2d3">More...</a><br /></td></tr>
<tr class="separator:a7415d78b8a2323b88e108fa1ea3bf2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_o_r_b___s_l_a_m2_1_1_optimizer.html" title="Optimizer concentra todas las operaciones con g2o. ">Optimizer</a> concentra todas las operaciones con <a class="el" href="namespaceg2o.html">g2o</a>. </p>
<p>Esta clase no tiene propiedades, sino solamente un conjunto métodos estáticos o de clase. <a class="el" href="class_o_r_b___s_l_a_m2_1_1_optimizer.html" title="Optimizer concentra todas las operaciones con g2o. ">Optimizer</a> no se instancia, funciona como un espacio de nombres. Reune las seis funciones implementadas con el framwork <a class="el" href="namespaceg2o.html">g2o</a>, que incluyen bundle adjustment, pose optimization y graph optimization. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aac6bf926792ed8a013d64897879a89ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::Optimizer::BundleAdjustment </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>vpKF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>vpMP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nIterations</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pbStopFlag</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long&#160;</td>
          <td class="paramname"><em>nLoopKF</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>bRobust</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bundle adjusment sobre los keyframes y puntos el mapa pasados como argumentos. </p>
<p>Toma todos los keyframes y todos los puntos del mapa, para ejecutar un BA. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vpKFs</td><td>Vector de keyframes. Cada keyframe contiene los puntos 2d visualizados, y su relación con los puntos del mapa. </td></tr>
    <tr><td class="paramname">vpMP</td><td>Vector de puntos del mapa. </td></tr>
    <tr><td class="paramname">nIterations</td><td>Cantidad de iteraciones máximas para el BA. </td></tr>
    <tr><td class="paramname">pbStopFlag</td><td>Señal para forzar la parada del optimizador. </td></tr>
    <tr><td class="paramname">nLoopKF</td><td></td></tr>
    <tr><td class="paramname">bRobust</td><td>Señal que solicita un evaluador robusto (que admite outliers) en lugar de uno estricto (que asume que todos los puntos son válidos).</td></tr>
  </table>
  </dd>
</dl>
<p>Este método se invoca solamente desde GlobalBundleAdjustment. </p>

</div>
</div>
<a id="aaa9b8a4c16296bf2981b0aaf4ee3189c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::Optimizer::GlobalBundleAdjustemnt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_map.html">Map</a> *&#160;</td>
          <td class="paramname"><em>pMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nIterations</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pbStopFlag</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long&#160;</td>
          <td class="paramname"><em>nLoopKF</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>bRobust</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ejecuta BundleAdjstment tomando los datos del mapa. </p>
<p>Toma todos los keyframes y todos los puntos del mapa, para ejecutar un BA. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMap</td><td>Mapa, de donde tomar todos los keyframes y los puntos. </td></tr>
    <tr><td class="paramname">nIterations</td><td>Cantidad de iteraciones máximas para el BA, pasado tal cual a BundleAdjustment. </td></tr>
    <tr><td class="paramname">pbStopFlag</td><td>Señal para forzar la parada del optimizador, pasado tal cual a BundleAdjustment. </td></tr>
    <tr><td class="paramname">nLoopKF</td><td></td></tr>
    <tr><td class="paramname">bRobust</td><td>Señal que solicita un evaluador robusto (que admite outliers) en lugar de uno estricto (que asume que todos los puntos son válidos).</td></tr>
  </table>
  </dd>
</dl>
<p>Este método se invoca solamente desde Tracking::createInitialMap al inicio del tracking, cuando el mapa es pequeno. </p>

</div>
</div>
<a id="ab70e0b4f366b65a0c1ae8b2def19d339"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::Optimizer::LocalBundleAdjustment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pKF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pbStopFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_map.html">Map</a> *&#160;</td>
          <td class="paramname"><em>pMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bundle adjusment local a partir de un keyframe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pKF</td><td>Keyframe inicial, usualmente Tracking::mpCurrentKeyFrame. </td></tr>
    <tr><td class="paramname">pbStopFlag</td><td>Señal para forzar la parada del optimizador. </td></tr>
    <tr><td class="paramname">pMap</td><td>Mapa del mundo.</td></tr>
  </table>
  </dd>
</dl>
<p>El BA local toma el keyframe de referencia (usualmente el actual). A partir de él forma un vector de keyframes covisibles con GetVectorCovisibleKeyFrames(), y un vector de puntos del mapa vistos por ellos. Estos keyframes y puntos del mapa serán modificados por el BA. Finalmente crea un vector de keyframes fijos (no afectados por el BA), con los otros keyframes que también observan esos puntos. Con estos datos ejecuta un BA usando <a class="el" href="namespaceg2o.html">g2o</a>.</p>
<p>Éste es el Bundle adjustment periódico del tracking.</p>
<p>Este método se invoca solamente desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_local_mapping.html#a0f9fa8a0236f55629b0f485db05deb2c" title="Bucle principal del thread de mapeo local. ">LocalMapping::Run()</a>.</p>
<p>El optimizador se arma así: </p><pre class="fragment">typedef BlockSolver&lt; BlockSolverTraits&lt; Eigen::Dynamic, Eigen::Dynamic &gt; &gt; BlockSolverX;
g2o::SparseOptimizer optimizer;
optimizer.setAlgorithm(
    new g2o::OptimizationAlgorithmLevenberg(
        new g2o::BlockSolverX(
            new g2o::LinearSolverEigen&lt;g2o::BlockSolverX::PoseMatrixType&gt;()
        )
    )
);
</pre><p>PoseMatrixType es MatrixXD, es decir de elementos double y dimensiones por definir. Este código significa: optimizador espaciado, con algoritmo LM, solucionador de bloque para poses de n dimensiones y puntos de m dimensiones, usando Cholesky espaciado de la librería Eigen. </p>

</div>
</div>
<a id="a5a53ab409feed7f92547eb79a2d7f6e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::Optimizer::OptimizeEssentialGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_map.html">Map</a> *&#160;</td>
          <td class="paramname"><em>pMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pLoopKF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pCurKF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_r_b___s_l_a_m2_1_1_loop_closing.html#ae9ada143a8308ce32990a7c7b5d533ab">LoopClosing::KeyFrameAndPose</a> &amp;&#160;</td>
          <td class="paramname"><em>NonCorrectedSim3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_r_b___s_l_a_m2_1_1_loop_closing.html#ae9ada143a8308ce32990a7c7b5d533ab">LoopClosing::KeyFrameAndPose</a> &amp;&#160;</td>
          <td class="paramname"><em>CorrectedSim3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *, set&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>LoopConnections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>bFixScale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optimiza el grafo esencial para cerrar un bucle. </p>
<p>Al detectar un cierre de bucle, se unen los extremos. Este método realiza un "pose graph optimization"; ejecuta un BA para repartir el error cuadrático medio a lo largo del grafo esencial. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMap</td><td>Mapa completo. </td></tr>
    <tr><td class="paramname">pLoopKF</td><td>Keyframe del extremo anterior del bucle. </td></tr>
    <tr><td class="paramname">pCurKF</td><td>Keyframe actual, del extremo posterior del bucle. </td></tr>
    <tr><td class="paramname">Scurw</td><td>Transformación Sim3 necesaria para adaptar el extremo posterior al anterior. No utilizado. </td></tr>
    <tr><td class="paramname">NonCorrectedSim3</td><td>KeyframeAndPose de los keyframes actual y vecinos, versión sin transformar sim3. </td></tr>
    <tr><td class="paramname">CorrectedSim3</td><td>KeyframeAndPose de los keyframes vecinos, versión corregida por sim3. </td></tr>
    <tr><td class="paramname">LoopConnections</td><td>Conjunto de keyframes conectados gracias al cierre del bucle.</td></tr>
  </table>
  </dd>
</dl>
<p>Este método se invoca exclusivamente en la etapa final de <a class="el" href="class_o_r_b___s_l_a_m2_1_1_loop_closing.html#aa007e0678582ec0de5d71280d23af540" title="Corrige el bucle con los encastres elaborados por LoopClosing::ComputeSim3. ">LoopClosing::CorrectLoop()</a>.</p>
<p>Carga en el optimizador todos los keyframes del mapa, marcando como fijo solamente al del extremo anterior del bucle. Carga todos los ejes del mapa: las conexiones entre keyframes, agregando las nuevas conexiones del bucle informadas en loopConnections. Ejecuta 20 iteraciones, y vuelca el resultado a las poses de los keyframes y de las posiciones de los puntos, recomputando normal y profundidad.</p>
<p>El optimizador se arma así: </p><pre class="fragment">typedef  BlockSolver&lt; BlockSolverTraits&lt; 7, 3 &gt; &gt; BlockSolver_7_3;
g2o::SparseOptimizer optimizer;
g2o::OptimizationAlgorithmLevenberg* solver = new g2o::OptimizationAlgorithmLevenberg(
    new g2o::BlockSolver_7_3(
        new g2o::LinearSolverEigen&lt;g2o::BlockSolver_7_3::PoseMatrixType&gt;()
    )
);
solver-&gt;setUserLambdaInit(1e-16);
optimizer.setAlgorithm(solver);
</pre><p>PoseMatrixType significa que para el hessiano de puntos se usan matrices double de 3x3, y para el hessiano de poses matrices double de 7x7. Este código significa: optimizador espaciado, con algoritmo LM, solucionador de bloque para poses de 7 dimensiones y puntos de 3 dimensiones, usando Cholesky espaciado de la librería Eigen.</p>
<p>A diferencia de PoseOptimization y LocalBundleAdjustment, se usa un BlockSolver_7_3 en lugar del BlockSolverX, y se le ajusta el LambdaInit. </p>

</div>
</div>
<a id="a91fbb960965c99e9802a5de45515813c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ORB_SLAM2::Optimizer::OptimizeSim3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pKF1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pKF2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>vpMatches1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structg2o_1_1_sim3.html">g2o::Sim3</a> &amp;&#160;</td>
          <td class="paramname"><em>g2oS12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>th2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>bFixScale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determina la transformación sim3 entre dos keyframes, que mejor explica un macheo. </p>
<p>Dados dos keyframes que presumiblemente observan lo mismmo y son candidatos a cierre de bucle, y dada una serie de puntos macheados observados por ambos keyframes, <a class="el" href="class_o_r_b___s_l_a_m2_1_1_optimizer.html#a91fbb960965c99e9802a5de45515813c" title="Determina la transformación sim3 entre dos keyframes, que mejor explica un macheo. ">OptimizeSim3()</a> calcula la transformación de similaridad sim3 que compatibiliza ambas visualizaciones y permite cerrar el bucle.</p>
<p>ESte método se invoca exclusivamente desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_loop_closing.html#ab4fcf814eed5b5dd2aec96454561b078" title="Procesa la lista de candidatos intentando corregir su pose. ">LoopClosing::ComputeSim3()</a>.</p>
<p>El optimizador se arma así, idéntico al de LocalBundleAdjustment:</p>
<p><a class="el" href="classg2o_1_1_sparse_optimizer.html">g2o::SparseOptimizer</a> optimizer; optimizer.setAlgorithm( new <a class="el" href="classg2o_1_1_optimization_algorithm_levenberg.html" title="Implementation of the Levenberg Algorithm. ">g2o::OptimizationAlgorithmLevenberg</a>( new <a class="el" href="namespaceg2o.html#a8d3214273331c25cbb5d5266770e6c12">g2o::BlockSolverX</a>( new g2o::LinearSolverEigen&lt;g2o::BlockSolverX::PoseMatrixType&gt;() ) ) ); </p>

</div>
</div>
<a id="a7415d78b8a2323b88e108fa1ea3bf2d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ORB_SLAM2::Optimizer::PoseOptimization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html">Frame</a> *&#160;</td>
          <td class="paramname"><em>pFrame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cómputo de la pose de un cuadro. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFrame</td><td>Calcula la pose del frame a partir de los puntos observados y sus posiciones en el mapa. La pose es una matriz de rototraslación de 4x4 en coordenadas homogéneas. Usa la pose del cuadro pFrame-&gt;mTcw como estimación inicial, usualmente la estimada por el modelo de movimiento, aunque puede también ser recuperada por relocalización. Éste es el único método que calcula la pose final de un cuadro. Se invoca para cada cuadro. Las poses de los cuadros son establecidas principalmente por este método, aunque también otros métodos (de <a class="el" href="class_o_r_b___s_l_a_m2_1_1_tracking.html" title="Objeto único que se ejecuta en su propio Trhead, y se inicia con Run(). ">Tracking</a>) inicializan la pose, la copian o estiman por modelo de movimiento.</td></tr>
    <tr><td class="paramname">pFrame</td><td>Cuadro con macheos contra puntos del mapa, cuya pose se quiere calcular. La pose se guarda en pFrame-&gt;mTcw. En OrbSlam siempre es el cuadro actual. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>La cantidad de correspondencias optimizadas (macheos sobrevivientes, inliers).</dd></dl>
<p>El optimizador se arma así, idéntico al de LocalBundleAdjustment:</p>
<p><a class="el" href="classg2o_1_1_sparse_optimizer.html">g2o::SparseOptimizer</a> optimizer; optimizer.setAlgorithm( new <a class="el" href="classg2o_1_1_optimization_algorithm_levenberg.html" title="Implementation of the Levenberg Algorithm. ">g2o::OptimizationAlgorithmLevenberg</a>( new <a class="el" href="namespaceg2o.html#a8d3214273331c25cbb5d5266770e6c12">g2o::BlockSolverX</a>( new g2o::LinearSolverDense&lt;g2o::BlockSolverX::PoseMatrixType&gt;() ) ) ); </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/alejandro/Desarrollo eclipse/os1/include/<a class="el" href="_optimizer_8h_source.html">Optimizer.h</a></li>
<li>/home/alejandro/Desarrollo eclipse/os1/src/<a class="el" href="_optimizer_8cc.html">Optimizer.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_o_r_b___s_l_a_m2.html">ORB_SLAM2</a></li><li class="navelem"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_optimizer.html">Optimizer</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>
